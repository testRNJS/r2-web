// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@readium/shared-models/lib/models/publication/publication
//   ../@readium/shared-models/lib/models/publication/link
//   ../@readium/shared-models/lib/models/publication/interfaces/link-core
//   ../@readium/shared-models/lib/models/publication/interfaces/properties-core

import { Publication as ReadiumWebPub } from '@readium/shared-models/lib/models/publication/publication';
import { Link } from '@readium/shared-models/lib/models/publication/link';
import { Relation } from '@readium/shared-models/lib/models/publication/interfaces/link-core';
import { PageProperty } from '@readium/shared-models/lib/models/publication/interfaces/properties-core';

export class Publication extends ReadiumWebPub {
    readonly spine: Link[];
    constructor(sourceURI?: string);
    static fromModel(publication: ReadiumWebPub, sourceURI?: string): Publication;
    static fromJSON(webPubManifestJSON: string, sourceURI?: string): Publication;
    static fromURL(publicationURL: string): Promise<Publication>;
    searchLinkByRel(rel: Relation): Link | undefined;
    getBaseURI(): string | undefined;
    getHrefRelativeToManifest(href: string): string;
    findSpineItemIndexByHref(href: string): number;
    isInternalHref(href: string): boolean;
}

export class PageTitleTocResolver {
    constructor(rend: Rendition);
    getPageTitleFromLocation(loc: Location): string;
    getTocLinkFromLocation(loc: Location): Link | null;
}

type OnSizeUpdateCallback = () => void;
export class ViewportResizer {
    constructor(rendCtx: RenditionContext, updateCallback: OnSizeUpdateCallback);
    stopListenResize(): void;
}
export {};

export class Navigator {
    constructor(rendition: Rendition, requestManager?: NavigationRequestManager);
    nextScreen(): Promise<void>;
    previousScreen(): Promise<void>;
    nextSpineItem(): Promise<void>;
    previousSpineItem(): Promise<void>;
    ensureLoaded(): Promise<void>;
    getCurrentLocationAsync(): Promise<Location | undefined | null>;
    getCurrentLocation(): Location | undefined | null;
    gotoBegin(): Promise<void>;
    gotoLocation(loc: Location): Promise<void>;
    gotoAnchorLocation(href: string, eleId: string): Promise<void>;
    getScreenBeginAsync(): Promise<Location | undefined | null>;
    getScreenBegin(): Location | undefined | null;
    getScreenEndAsync(): Promise<Location | undefined | null>;
    getScreenEnd(): Location | undefined | null;
    isFirstScreen(): boolean;
    isLastScreen(): boolean;
    isFirstScreenSpine(): boolean;
    isFinalScreenSpine(): boolean;
    getScreenCountSpine(): number;
}

export class RenditionContext {
    requestManager: NavigationRequestManager;
    rendition: Rendition;
    navigator: Navigator;
    constructor(rendition: Rendition, iframeLoader: IFrameLoader);
}

export class ReadingSystem {
    initRenderer(viewport: HTMLElement): void;
    openRendition(pub: Publication): Rendition;
}

export class Location {
    constructor(cfi: string, href: string, isPrecise?: boolean);
    getLocation(): string;
    getHref(): string;
    getLocationPrecision(): boolean;
}

export enum SpreadMode {
    Freeform = 0,
    FitViewportAuto = 1,
    FitViewportSingleSpread = 2,
    FitViewportDoubleSpread = 3
}
export interface PageLayoutSettings {
    spreadMode: SpreadMode;
    pageWidth?: number;
    pageHeight?: number;
}
export class Rendition {
    viewport: Viewport;
    constructor(pub: Publication, viewport: HTMLElement, cvFactory: IContentViewFactory);
    reset(): void;
    setPageLayout(layoutSetting: PageLayoutSettings): void;
    refreshPageLayout(): void;
    updateViewSettings(settings: ISettingEntry[]): void;
    viewSettings(): ViewSettings;
    setZoom(option: ZoomOptions, scale: number): void;
    getZoomScale(): number;
    getZoomOption(): ZoomOptions;
    setViewAsVertical(v: boolean): void;
    getPageWidth(): number;
    getPublication(): Publication;
    getCfiFromAnchor(href: string, elementId: string): string | undefined;
    render(): Promise<void>;
}

interface IR1AttachedDataType {
    spineItem: any;
}
interface ILoaderConfig {
    useReadiumCss?: boolean;
    useReadiumCssOverride?: boolean;
}
export class IFrameLoader {
    constructor(publicationURI?: string);
    setReadiumCssBasePath(path: string): void;
    addIFrameLoadedListener(callback: Function): void;
    loadIframe(iframe: HTMLIFrameElement, src: string, callback: any, config: ILoaderConfig, attachedData: string | IR1AttachedDataType): void;
}
export {};

export class NavigationRequestManager {
    startRequest(): CancellationToken;
    endRequest(cancelToken: CancellationToken): void;
    executeNavigationAction(navAction: (token: CancellationToken) => Promise<void>): Promise<void>;
}

export enum ContentLoadingStatus {
    NotLoaded = 0,
    Loading = 1,
    Loaded = 2
}
export class SpineItemView extends View {
    protected host: HTMLElement;
    protected spine: Link[];
    protected cvFactory: IContentViewFactory;
    protected spineItem: Link;
    protected spineItemIndex: number;
    protected spineItemPageCount: number;
    protected isInUse: boolean;
    protected contentStatus: ContentLoadingStatus;
    protected isVertical: boolean;
    protected isFixedLayout: boolean;
    protected scaleOption: ZoomOptions;
    protected scale: number;
    protected contentHeight: number;
    protected contentView: IContentView;
    constructor(spine: Link[], isVertical: boolean, isFixedLayout: boolean, cvFactory: IContentViewFactory);
    getContentView(): IContentView;
    getOffsetFromCfi(cfi: string): number;
    getPageIndexOffsetFromCfi(cfi: string): number;
    getOffsetFromElementId(elementId: string): number;
    getPageIndexOffsetFromElementId(elementId: string): number;
    loadSpineItem(spineItem: Link, viewSettings: ViewSettings, token?: CancellationToken): Promise<void>;
    unloadSpineItem(): void;
    isSpineItemInUse(): boolean;
    fixedLayout(): boolean;
    ensureContentLoaded(token?: CancellationToken): Promise<void>;
    isContentLoaded(): boolean;
    resize(pageWidth: number, pageHeight: number): void;
    getScale(): number;
    setZoomOption(option: ZoomOptions): void;
    resizeFixedLayoutPage(option: ZoomOptions, pageWidth: number, pageHeight: number): void;
    setViewSettings(viewSetting: ViewSettings): void;
    render(): void;
    attachToHost(host: HTMLElement): void;
    getTotalPageCount(): number;
    setTotalPageCount(count: number): void;
    getTotalSize(pageWidth: number): number;
    getPageSize(pageWidth: number): number;
    getCfi(offsetMain: number, offset2nd: number, backward: boolean): string;
    getCfiFromElementId(elementId: string): string;
    onSelfResize(callback: SelfResizeCallbackType): void;
    show(): void;
    hide(): void;
}

export enum ScrollMode {
    None = 0,
    Publication = 1,
    SpineItem = 2
}
export class Viewport {
    constructor(root: HTMLElement);
    addLocationChangedListener(callback: Function): void;
    setView(v: LayoutView): void;
    reset(): void;
    setScrollMode(mode: ScrollMode): void;
    setViewportSize(size: number, size2nd: number): void;
    getViewportSize(): number;
    getViewportSize2nd(): number;
    setPrefetchSize(size: number): void;
    getStartPosition(): PaginationInfo | undefined;
    getEndPosition(): PaginationInfo | undefined;
    renderAtOffset(pos: number, token?: CancellationToken): Promise<void>;
    renderAtSpineItem(spineItemIndex: number, token?: CancellationToken): Promise<void>;
    renderAtLocation(loc: Location, token?: CancellationToken): Promise<void>;
    renderAtAnchorLocation(href: string, eleId: string, token?: CancellationToken): Promise<void>;
    nextScreen(token?: CancellationToken): Promise<void>;
    prevScreen(token?: CancellationToken): Promise<void>;
    nextSpineItem(token?: CancellationToken): Promise<void>;
    prevSpineItem(token?: CancellationToken): Promise<void>;
    ensureLoaded(token?: CancellationToken): Promise<void>;
    visibleSpineItemIndexRange(): number[];
    getSpineItemView(spineItemIndex: number): SpineItemView | undefined;
    getOffsetInSpineItemView(siIndex: number): number | undefined;
    onVisiblePagesReady(callback: (cv: IContentView) => void): void;
    getViewScale(siIndex: number): number;
    beginViewUpdate(): void;
    endViewUpdate(): void;
}

export class ViewSettings {
    getAllSettings(): ISettingEntry[];
    updateSetting(newSettings: ISettingEntry[]): void;
    updateView(view: HTMLElement): void;
    getSetting<T>(name: SettingName): T | undefined;
    getSettingWithDefaultValue<T>(name: SettingName, defaultVal: T): T;
}

export class PaginationInfo {
    spineItemIndex: number;
    spineItemPageCount: number;
    pageIndex: number;
    view: SpineItemView;
    offsetInView: number;
}
export class LayoutView extends View {
    constructor(pub: Publication, vs: ViewSettings, cvFactory: IContentViewFactory);
    reset(): void;
    getSpineItemView(spineItemIndex: number): SpineItemView | undefined;
    getSpineItemViewOffset(spineItemIndex: number): number | undefined;
    isSpineItemVisible(siIndex: number, viewOffset: number, viewportSize: number): boolean;
    getOffsetInSpineItemView(siIndex: number, viewOffset: number): number | undefined;
    findSpineItemIndexByHref(href: string): number;
    isRightToLeft(): boolean;
    setPageSize(width: number, height: number): void;
    setNumberOfPagesPerSpread(num: number): void;
    numberOfPagesPerSpread(): number;
    beginViewUpdate(): void;
    endViewUpdate(): void;
    updateViewSettings(): void;
    setZoom(option: ZoomOptions, scale: number): void;
    getZoomScale(): number;
    getZoomOption(): ZoomOptions;
    setVerticalLayout(v: boolean): void;
    isVerticalLayout(): boolean;
    render(): void;
    attachToHost(host: HTMLElement): void;
    containerElement(): HTMLElement;
    hasMoreAfterEnd(): boolean;
    hasMoreBeforeStart(): boolean;
    getLoadedStartPostion(): number;
    getLoadedEndPosition(): number;
    isEmpty(): boolean;
    loadedRangeLength(): number;
    paginatedLength(): number;
    getPaginationInfoAtOffset(offset: number): PaginationInfo[];
    getOffsetFromLocation(loc: Location): Promise<number | undefined>;
    getOffsetFromAnchor(href: string, elementId: string): Promise<number | undefined>;
    getCfiFromAnchor(href: string, elementId: string): string | undefined;
    ensureLoaded(token?: CancellationToken): Promise<void>;
    ensureConentLoadedAtRange(start: number, end: number, token?: CancellationToken): Promise<void>;
    ensureContentLoadedAtSpineItemRange(startIndex: number, endIndex: number, token?: CancellationToken): Promise<void>;
    adjustLoadedConentRangeToPositive(): number;
    showOnlySpineItemRange(spineItemIndex: number): void;
    visiblePages(start: number, end: number): [number, number][];
    arrangeDoublepageSpreads(pos: number): PageProperty | undefined;
    removeOutOfRangeSpineItems(start: number, end: number): void;
}

export enum ZoomOptions {
    FitByWidth = 0,
    FitByHeight = 1,
    FitByPage = 2
}
export class CancellationToken {
    isCancelled: boolean;
}
export enum SettingName {
    ColumnGap = "column-gap",
    MaxColumnWidth = "column-max",
    MinColumnWidth = "column-min",
    SpreadMode = "spread-mode",
    FontFamily = "font-family",
    FontSize = "font-size",
    ReadingMode = "reading-mode",
    TextColor = "text-color",
    BackgroundColor = "background-color",
    TextAlign = "text-align",
    FontOverride = "font-override"
}
export interface ISettingEntry {
    name: SettingName;
    value: any;
}
export function stringToSettingName(val: string): SettingName | undefined;

export interface IVisibleElementInfo {
    element: HTMLElement | null;
    textNode: Node | null;
    percentVisible: number;
}
export class ElementBlacklistedChecker {
    constructor(clsList: string[], idList: string[], eleList: string[]);
    getClassBlacklist(): string[];
    getIdBlacklist(): string[];
    getElementBlacklist(): string[];
    isElementBlacklisted(node: Node | null): boolean;
}
export class ElementVisibilityChecker {
    constructor(doc: Document, columnSize: [number, number], viewport?: Rect, eleChecker?: ElementBlacklistedChecker);
    findFirstVisibleElement(fromEnd: boolean): IVisibleElementInfo;
    getVisibleTextRange(textNode: Node, toStart: boolean): Range;
    getElementStartOffset(ele: Node): [number, number] | null;
    getRangeStartOffset(range: Range): [number, number] | null;
    findNearestElement(ele: Node): [Node | null, boolean];
    getLeafNodeElements(root: Node | null): Node[];
}

export class CfiNavigationLogic {
    constructor(doc: Document, eleChecker: ElementBlacklistedChecker);
    setColumnSize(width: number, height: number): void;
    getCfiFromElementId(elementId: string): string | null;
    getCfiFromElement(element: Element): string;
    getFirstVisibleCfi(viewport: Rect, fromEnd: boolean): string | null;
    getOffsetByCfi(cfi: string): [number, number] | null;
    getElementByCfi(cfi: string): Node | null;
    getOffsetFromElement(ele: Node): [number, number] | null;
    getOffsetFromElementId(eleId: string): [number, number] | null;
    getOffsetFromRange(range: Range): [number, number] | null;
    isRangeCfi(partialCfi: string): boolean;
    getElementById(eleId: string): HTMLElement | null;
}

export class Rect {
    left: number;
    top: number;
    right: number;
    bottom: number;
    constructor(left: number, top: number, right: number, bottom: number);
    static fromDOMRect(r: DOMRect): Rect;
    width(): number;
    height(): number;
    intersect(r: Rect): boolean;
    overlapHorizontal(rect: Rect): boolean;
    overlapVertical(rect: Rect): boolean;
    horizontalOverlap(rect: Rect): number;
    verticalOverlaop(rect: Rect): number;
}

export interface IContentViewFactory {
    createContentView(isFixedLayout: boolean, isVertical: boolean): IContentView;
}

export class R2ContentViewFactory implements IContentViewFactory {
    constructor(loader: IFrameLoader);
    setElementChecker(eleChecker: ElementBlacklistedChecker): void;
    createContentView(isFixedLayout: boolean, isVertical: boolean): IContentView;
}

export class R2SinglePageContentView extends R2ContentView {
    setLayout(isVert: boolean, isFxl: boolean): void;
    element(): HTMLElement;
    metaWidth(): number;
    metaHeight(): number;
    calculatedHeight(): number;
    render(): void;
    setViewSettings(viewSetting: ViewSettings): void;
    getOffsetFromCfi(cfi: string): number;
    getOffsetFromElementId(cfi: string): number;
    getPageIndexOffsetFromCfi(cfi: string): number;
    getPageIndexOffsetFromElementId(elementId: string): number;
    getCfi(offsetMain: number, offset2nd: number, backward: boolean): string;
    scale(scale: number): void;
    spineItemPageCount(): number;
    onResize(): void;
    protected onIframeLoaded(success: boolean): void;
}

export type SelfResizeCallbackType = (spineItemIndex: number) => void;
export interface IContentView {
    render(): void;
    loadSpineItem(spineItem: Link, spineItemIndex: number, viewSettings: ViewSettings, token?: CancellationToken): Promise<void>;
    spineItemLoadedPromise(token?: CancellationToken): Promise<void>;
    unloadSpineItem(): void;
    attachToHost(host: HTMLElement): void;
    setViewSettings(viewSetting: ViewSettings): void;
    scale(scale: number): void;
    element(): HTMLElement;
    metaWidth(): number;
    metaHeight(): number;
    calculatedHeight(): number;
    spineItemPageCount(): number;
    getOffsetFromCfi(cfi: string): number;
    getOffsetFromElementId(cfi: string): number;
    getPageIndexOffsetFromCfi(cfi: string): number;
    getPageIndexOffsetFromElementId(elementId: string): number;
    getCfi(offsetMain: number, offset2nd: number, backward: boolean): string;
    getCfiFromElementId(elementId: string): string;
    onResize(): void;
    onSelfResize(callback: SelfResizeCallbackType): void;
}

export abstract class View {
    parent: View;
    abstract render(): void;
    abstract attachToHost(host: HTMLElement): void;
}

type IframeLoadedCallback = (success: boolean) => void;
export class R2ContentView implements IContentView {
    protected host: HTMLElement;
    protected iframeLoader: IFrameLoader;
    protected iframeContainer: HTMLElement;
    protected iframe: HTMLIFrameElement;
    protected iframeLoadedCallbacks: IframeLoadedCallback[];
    protected spineItem: Link;
    protected spineItemIndex: number;
    protected spineItemPgCount: number;
    protected ePubHtml: HTMLHtmlElement | null;
    protected ePubBody: HTMLBodyElement | null;
    protected useReadiumCss: boolean;
    protected useReadiumCssOverride: boolean;
    protected vs: ViewSettings;
    protected elementChecker: ElementBlacklistedChecker;
    protected cfiNavLogic: CfiNavigationLogic;
    constructor(loader: IFrameLoader, eleChecker: ElementBlacklistedChecker);
    render(): void;
    loadSpineItem(spineItem: Link, spineItemIndex: number, viewSettings: ViewSettings, token?: CancellationToken | undefined): Promise<void>;
    spineItemLoadedPromise(token?: CancellationToken | undefined): Promise<void>;
    unloadSpineItem(): void;
    attachToHost(host: HTMLElement): void;
    setViewSettings(viewSetting: ViewSettings): void;
    scale(scale: number): void;
    element(): HTMLElement;
    metaWidth(): number;
    metaHeight(): number;
    calculatedHeight(): number;
    spineItemPageCount(): number;
    getOffsetFromCfi(cfi: string): number;
    getOffsetFromElementId(cfi: string): number;
    getPageIndexOffsetFromCfi(cfi: string): number;
    getPageIndexOffsetFromElementId(elementId: string): number;
    getCfi(offsetMain: number, offset2nd: number, backward: boolean): string;
    getCfiFromElementId(elementId: string): string;
    onResize(): void;
    onSelfResize(callback: SelfResizeCallbackType): void;
    protected setupIframe(): void;
    protected hideIframe(): void;
    protected showIFrame(): void;
    protected iframeLoadedPromise(token?: CancellationToken): Promise<void>;
    protected onIframeLoaded(success: boolean): void;
    protected getHostSize(): [number, number] | null;
}
export {};

